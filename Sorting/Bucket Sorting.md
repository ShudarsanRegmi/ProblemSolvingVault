
```
**function** bucketSort(array, k) **is**
    buckets ← new array of k empty lists
    M ← 1 + the maximum key value in the array
    **for** i = 0 **to** length(array) **do**
        insert _array[i]_ into _buckets[floor(k × array[i] / M)]_
    **for** i = 0 **to** k **do** 
        nextSort(buckets[i])
    **return** the concatenation of buckets[0], ...., buckets[k]
```


This pseudocode is a generalized form of **bucket sort**, where:

- **`k`** represents the number of buckets.
- **`M`** is used to normalize the values of the input array so that elements are mapped to appropriate buckets based on their range.
- **`nextSort`** is the sorting function applied to each bucket (commonly `insertionSort` or `std::sort` in C++).



### Classical Code 
```cpp
#include <iostream>
#include <vector>
using namespace std;

// Insertion sort function to sort individual buckets
void insertionSort(vector<float>& bucket) {
    for (int i = 1; i < bucket.size(); ++i) {
        float key = bucket[i];
        int j = i - 1;
        while (j >= 0 && bucket[j] > key) {
            bucket[j + 1] = bucket[j];
            j--;
        }
        bucket[j + 1] = key;
    }
}

// Function to sort arr[] of size n using bucket sort
void bucketSort(float arr[], int n) {
    // 1) Create n empty buckets
    vector<float> b[n];

    // 2) Put array elements in different buckets
    for (int i = 0; i < n; i++) {
        int bi = n * arr[i];
        b[bi].push_back(arr[i]);
    }

    // 3) Sort individual buckets using insertion sort
    for (int i = 0; i < n; i++) {
        insertionSort(b[i]);
    }

    // 4) Concatenate all buckets into arr[]
    int index = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < b[i].size(); j++) {
            arr[index++] = b[i][j];
        }
    }
}

// Driver program to test above function
int main() {
    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};
    int n = sizeof(arr) / sizeof(arr[0]);
    bucketSort(arr, n);

    cout << "Sorted array is \n";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    return 0;
}

```


### Code With Generic Bucket Logic
```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm> // For std::sort
using namespace std;

// Function to perform bucket sort
void bucketSort(vector<int>& array, int k) {
    int n = array.size();

    // Step 1: Find the maximum value in the array
    int maxValue = *max_element(array.begin(), array.end());

    // Step 2: Create 'k' empty buckets
    vector<vector<int>> buckets(k);

    // Step 3: Distribute array elements into buckets
    for (int i = 0; i < n; i++) {
        int bucketIndex = floor(k * array[i] / (maxValue + 1)); // Normalize and map to bucket
        buckets[bucketIndex].push_back(array[i]);
    }

    // Step 4: Sort individual buckets
    for (int i = 0; i < k; i++) {
        sort(buckets[i].begin(), buckets[i].end()); // Use any sorting method
    }

    // Step 5: Concatenate all buckets back into the array
    int index = 0;
    for (int i = 0; i < k; i++) {
        for (int num : buckets[i]) {
            array[index++] = num;
        }
    }
}

// Driver code to test bucket sort
int main() {
    vector<int> array = {78, 92, 30, 45, 67, 88, 12, 15, 100, 55};
    int k = 5; // Number of buckets

    cout << "Original array: ";
    for (int num : array) {
        cout << num << " ";
    }
    cout << endl;

    bucketSort(array, k);

    cout << "Sorted array: ";
    for (int num : array) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}

```


![[Pasted image 20241211172348.png]]

### Time Complexity
- **Best Case:** $O(n+k)$
- Worst Case: $O(n^2)$ // complexity of underlying algorithm to be used
- Average Case:

## Auxiliary Space
- $O(n+k)$

## Generic Bucket Sort

The most common variant of bucket sort operates on a list of _n_ numeric inputs between zero and some maximum value _M_ and divides the value range into _b_ buckets each of size _M_/_b_. If each bucket is sorted using [insertion sort](https://en.wikipedia.org/wiki/Insertion_sort "Insertion sort"), the sort can be shown to run in expected linear time (where the average is taken over all possible inputs) However, the performance of this sort degrades with clustering; if many values occur close together, they will all fall into a single bucket and be sorted slowly. This performance degradation is avoided in the original bucket sort algorithm by assuming that the input is generated by a random process that distributes elements uniformly over the interval _[0,1)]

